<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Granite - Markdown Rendering Tests</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 20px; }
        button {
            background: #2196f3;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
        }
        button:hover { background: #1976d2; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .summary {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .summary-item {
            padding: 15px 20px;
            border-radius: 8px;
            flex: 1;
            text-align: center;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .summary-item.total { border-left: 4px solid #2196f3; }
        .summary-item.passed { border-left: 4px solid #4caf50; }
        .summary-item.failed { border-left: 4px solid #f44336; }
        .summary-value { font-size: 36px; font-weight: bold; margin: 5px 0; }
        .summary-label { font-size: 14px; color: #666; }
        .test-case {
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid #e0e0e0;
            background: white;
        }
        .test-case.pass { border-left-color: #4caf50; background: #f1f8f4; }
        .test-case.fail { border-left-color: #f44336; background: #fef1f0; }
        .test-name { font-weight: 600; margin-bottom: 4px; }
        .test-result { font-size: 13px; color: #555; }
        .test-details { font-size: 12px; color: #777; margin-top: 6px; font-family: monospace; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>Markdown Rendering Tests</h1>
    <p class="subtitle">Unit tests for wikilink resolution, image embeds, frontmatter stripping, and link classification</p>

    <button id="runTests" onclick="runAllTests()">Run All Tests</button>

    <div class="summary">
        <div class="summary-item total">
            <div class="summary-label">Total</div>
            <div class="summary-value" id="totalTests">0</div>
        </div>
        <div class="summary-item passed">
            <div class="summary-label">Passed</div>
            <div class="summary-value" id="passedTests">0</div>
        </div>
        <div class="summary-item failed">
            <div class="summary-label">Failed</div>
            <div class="summary-value" id="failedTests">0</div>
        </div>
    </div>

    <div id="testResults"></div>

    <!-- Hidden container for DOM manipulation tests -->
    <div id="test-container" style="display: none;"></div>

    <script>
        let passed = 0, failed = 0, total = 0;

        function displayTest(name, status, message, details) {
            total++;
            if (status === 'pass') passed++;
            else failed++;
            const div = document.createElement('div');
            div.className = `test-case ${status}`;
            let html = `<div class="test-name">${status === 'pass' ? '✓' : '✗'} ${name}</div><div class="test-result">${message}</div>`;
            if (details) {
                html += `<details><summary>Details</summary><div class="test-details">${details}</div></details>`;
            }
            div.innerHTML = html;
            document.getElementById('testResults').appendChild(div);
            updateSummary();
        }

        function updateSummary() {
            document.getElementById('totalTests').textContent = total;
            document.getElementById('passedTests').textContent = passed;
            document.getElementById('failedTests').textContent = failed;
        }

        // --- Wikilink resolution logic (extracted from markdown.js) ---

        function resolveWikilinks(content, notes, allFolders) {
            return content.replace(
                /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
                (match, target, displayText) => {
                    const linkTarget = target.trim();
                    const linkText = displayText ? displayText.trim() : linkTarget;
                    const linkTargetLower = linkTarget.toLowerCase();

                    const noteExists = notes.some(n => {
                        const pathLower = n.path.toLowerCase();
                        const nameLower = n.name.toLowerCase();
                        return (
                            n.path === linkTarget ||
                            n.path === linkTarget + '.md' ||
                            pathLower === linkTargetLower ||
                            pathLower === linkTargetLower + '.md' ||
                            n.name === linkTarget ||
                            n.name === linkTarget + '.md' ||
                            nameLower === linkTargetLower ||
                            nameLower === linkTargetLower + '.md' ||
                            n.path.endsWith('/' + linkTarget) ||
                            n.path.endsWith('/' + linkTarget + '.md') ||
                            pathLower.endsWith('/' + linkTargetLower) ||
                            pathLower.endsWith('/' + linkTargetLower + '.md')
                        );
                    });

                    const folderExists = allFolders.some(f => {
                        const folderLower = f.toLowerCase();
                        const folderName = f.split('/').pop();
                        const folderNameLower = folderName.toLowerCase();
                        return (
                            f === linkTarget ||
                            folderLower === linkTargetLower ||
                            folderName === linkTarget ||
                            folderNameLower === linkTargetLower ||
                            f.endsWith('/' + linkTarget) ||
                            folderLower.endsWith('/' + linkTargetLower)
                        );
                    });

                    const safeHref = linkTarget.replace(/"/g, '%22');
                    const safeText = linkText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const linkExists = noteExists || folderExists;
                    const brokenClass = linkExists ? '' : ' class="wikilink-broken"';
                    const folderAttr = (folderExists && !noteExists) ? ' data-folder-link="true"' : '';
                    return `<a href="${safeHref}"${brokenClass} data-wikilink="true"${folderAttr}>${safeText}</a>`;
                }
            );
        }

        // --- Image embed resolution logic (extracted from markdown.js) ---

        function resolveImageEmbeds(content, allImages) {
            return content.replace(
                /!\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
                (match, target, altText) => {
                    const imageTarget = target.trim();
                    const imageAlt = altText ? altText.trim() : imageTarget;
                    const imageTargetLower = imageTarget.toLowerCase();

                    const foundImage = allImages.find(img => {
                        const nameLower = img.name.toLowerCase();
                        return (
                            img.name === imageTarget ||
                            nameLower === imageTargetLower ||
                            img.path === imageTarget ||
                            img.path.toLowerCase() === imageTargetLower
                        );
                    });

                    if (foundImage) {
                        const encodedPath = foundImage.path.split('/').map(segment => encodeURIComponent(segment)).join('/');
                        const safeAlt = imageAlt.replace(/"/g, '&quot;').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        return `<img src="/api/images/${encodedPath}" alt="${safeAlt}" title="${safeAlt}" loading="lazy" />`;
                    } else {
                        const safeTarget = imageTarget.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        return `<span class="wikilink-broken" title="Image not found">![[${safeTarget}]]</span>`;
                    }
                }
            );
        }

        // --- Frontmatter stripping logic ---

        function stripFrontmatter(content) {
            if (content.trim().startsWith('---')) {
                const lines = content.split('\n');
                if (lines[0].trim() === '---') {
                    let endIdx = -1;
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim() === '---') {
                            endIdx = i;
                            break;
                        }
                    }
                    if (endIdx !== -1) {
                        return lines.slice(endIdx + 1).join('\n').trim();
                    }
                }
            }
            return content;
        }

        // --- Test data ---

        const MOCK_NOTES = [
            { path: 'Projects/readme.md', name: 'readme', type: 'note' },
            { path: 'journal.md', name: 'journal', type: 'note' },
            { path: 'Daily Notes/2024-01-15.md', name: '2024-01-15', type: 'note' },
            { path: 'Ideas/brainstorm.md', name: 'brainstorm', type: 'note' },
        ];

        const MOCK_IMAGES = [
            { path: 'images/screenshot.png', name: 'screenshot.png', type: 'image' },
            { path: 'Projects/diagram.svg', name: 'diagram.svg', type: 'image' },
            { path: 'photo with spaces.jpg', name: 'photo with spaces.jpg', type: 'image' },
        ];

        const MOCK_FOLDERS = ['Projects', 'Daily Notes', 'Ideas', 'Projects/Subproject'];

        // --- Test cases ---

        const tests = [
            // Wikilink resolution
            {
                name: 'Wikilink to existing note by name',
                run: () => {
                    const result = resolveWikilinks('See [[journal]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (!result.includes('data-wikilink="true"')) throw new Error('Missing wikilink attribute');
                    if (result.includes('wikilink-broken')) throw new Error('Link marked as broken');
                    if (!result.includes('>journal<')) throw new Error('Display text incorrect');
                    return result;
                }
            },
            {
                name: 'Wikilink to existing note by path',
                run: () => {
                    const result = resolveWikilinks('See [[Projects/readme]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (result.includes('wikilink-broken')) throw new Error('Link marked as broken');
                    return result;
                }
            },
            {
                name: 'Wikilink to nonexistent note is marked broken',
                run: () => {
                    const result = resolveWikilinks('See [[nonexistent note]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (!result.includes('wikilink-broken')) throw new Error('Broken link not marked');
                    return result;
                }
            },
            {
                name: 'Wikilink with custom display text',
                run: () => {
                    const result = resolveWikilinks('See [[journal|My Journal]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (!result.includes('>My Journal<')) throw new Error('Custom display text not used');
                    if (result.includes('wikilink-broken')) throw new Error('Link marked as broken');
                    return result;
                }
            },
            {
                name: 'Wikilink resolution is case-insensitive',
                run: () => {
                    const result = resolveWikilinks('See [[JOURNAL]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (result.includes('wikilink-broken')) throw new Error('Case-insensitive match failed');
                    return result;
                }
            },
            {
                name: 'Wikilink to folder gets folder attribute',
                run: () => {
                    const result = resolveWikilinks('Go to [[Projects]]', MOCK_NOTES, MOCK_FOLDERS);
                    if (!result.includes('data-folder-link="true"')) throw new Error('Missing folder link attribute');
                    if (result.includes('wikilink-broken')) throw new Error('Folder link marked as broken');
                    return result;
                }
            },
            {
                name: 'Note takes priority over folder with same name',
                run: () => {
                    // "brainstorm" exists as note in Ideas folder, "Ideas" is a folder
                    const result = resolveWikilinks('See [[Ideas]]', MOCK_NOTES, MOCK_FOLDERS);
                    // Ideas is only a folder, not a note — should have folder attr
                    if (!result.includes('data-folder-link="true"')) throw new Error('Should be a folder link');
                    return result;
                }
            },
            {
                name: 'Multiple wikilinks in one string',
                run: () => {
                    const result = resolveWikilinks('See [[journal]] and [[brainstorm]]', MOCK_NOTES, MOCK_FOLDERS);
                    const linkCount = (result.match(/data-wikilink="true"/g) || []).length;
                    if (linkCount !== 2) throw new Error(`Expected 2 wikilinks, got ${linkCount}`);
                    return result;
                }
            },
            {
                name: 'Wikilink with special characters in display text is escaped',
                run: () => {
                    const xssPayload = '<scr' + 'ipt>alert(1)<\/scr' + 'ipt>';
                    const result = resolveWikilinks('See [[journal|' + xssPayload + ']]', MOCK_NOTES, MOCK_FOLDERS);
                    if (result.includes('<scr' + 'ipt>')) throw new Error('XSS not escaped in display text');
                    if (!result.includes('&lt;script&gt;')) throw new Error('HTML entities not properly escaped');
                    return result;
                }
            },

            // Image embed resolution
            {
                name: 'Image embed for existing image',
                run: () => {
                    const result = resolveImageEmbeds('![[screenshot.png]]', MOCK_IMAGES);
                    if (!result.includes('<img')) throw new Error('No img tag generated');
                    if (!result.includes('/api/images/')) throw new Error('Missing API path');
                    if (!result.includes('loading="lazy"')) throw new Error('Missing lazy loading');
                    return result;
                }
            },
            {
                name: 'Image embed for nonexistent image shows broken indicator',
                run: () => {
                    const result = resolveImageEmbeds('![[nonexistent.png]]', MOCK_IMAGES);
                    if (!result.includes('wikilink-broken')) throw new Error('Missing broken indicator');
                    if (!result.includes('Image not found')) throw new Error('Missing error title');
                    return result;
                }
            },
            {
                name: 'Image embed with custom alt text',
                run: () => {
                    const result = resolveImageEmbeds('![[screenshot.png|My Screenshot]]', MOCK_IMAGES);
                    if (!result.includes('alt="My Screenshot"')) throw new Error('Custom alt text not applied');
                    if (!result.includes('title="My Screenshot"')) throw new Error('Custom title not applied');
                    return result;
                }
            },
            {
                name: 'Image embed encodes path with spaces',
                run: () => {
                    const result = resolveImageEmbeds('![[photo with spaces.jpg]]', MOCK_IMAGES);
                    if (!result.includes('photo%20with%20spaces.jpg')) throw new Error('Spaces not encoded');
                    return result;
                }
            },
            {
                name: 'Image embed resolution is case-insensitive',
                run: () => {
                    const result = resolveImageEmbeds('![[SCREENSHOT.PNG]]', MOCK_IMAGES);
                    if (!result.includes('<img')) throw new Error('Case-insensitive match failed');
                    return result;
                }
            },
            {
                name: 'Image embed by full path',
                run: () => {
                    const result = resolveImageEmbeds('![[Projects/diagram.svg]]', MOCK_IMAGES);
                    if (!result.includes('<img')) throw new Error('Full path match failed');
                    if (!result.includes('Projects/diagram.svg')) throw new Error('Path not preserved');
                    return result;
                }
            },

            // Frontmatter stripping
            {
                name: 'Strip YAML frontmatter from content',
                run: () => {
                    const content = '---\ntags:\n  - test\n---\n\n# Hello World';
                    const result = stripFrontmatter(content);
                    if (result.includes('tags:')) throw new Error('Frontmatter not stripped');
                    if (!result.includes('# Hello World')) throw new Error('Content removed');
                    return `"${result}"`;
                }
            },
            {
                name: 'Content without frontmatter is unchanged',
                run: () => {
                    const content = '# Just a heading\n\nSome text';
                    const result = stripFrontmatter(content);
                    if (result !== content) throw new Error('Content was modified');
                    return 'Content preserved';
                }
            },
            {
                name: 'Malformed frontmatter (no closing ---) is left intact',
                run: () => {
                    const content = '---\ntags:\n  - test\n\n# Hello';
                    const result = stripFrontmatter(content);
                    if (!result.includes('tags:')) throw new Error('Malformed frontmatter should not be stripped');
                    return 'Malformed frontmatter preserved';
                }
            },
            {
                name: 'Empty frontmatter is stripped',
                run: () => {
                    const content = '---\n---\n\n# Hello';
                    const result = stripFrontmatter(content);
                    if (result.includes('---')) throw new Error('Empty frontmatter not stripped');
                    if (!result.includes('# Hello')) throw new Error('Content removed');
                    return `"${result}"`;
                }
            },

            // Link classification in rendered HTML
            {
                name: 'External links get target="_blank" and rel="noopener"',
                run: () => {
                    const container = document.getElementById('test-container');
                    container.innerHTML = '<a href="https://example.com">External</a><a href="note" data-wikilink="true">Internal</a>';

                    // Apply the same logic from markdown.js
                    const links = container.querySelectorAll('a');
                    links.forEach(link => {
                        const href = link.getAttribute('href');
                        if (href && (href.startsWith('http://') || href.startsWith('https://') || href.startsWith('//'))) {
                            link.setAttribute('target', '_blank');
                            link.setAttribute('rel', 'noopener noreferrer');
                        }
                    });

                    const external = container.querySelector('a[href="https://example.com"]');
                    const internal = container.querySelector('a[data-wikilink]');
                    if (external.getAttribute('target') !== '_blank') throw new Error('External link missing target=_blank');
                    if (external.getAttribute('rel') !== 'noopener noreferrer') throw new Error('External link missing rel');
                    if (internal.getAttribute('target') === '_blank') throw new Error('Internal link should not have target=_blank');
                    container.innerHTML = '';
                    return 'External links annotated, internal links untouched';
                }
            },
        ];

        // --- Runner ---

        function runAllTests() {
            document.getElementById('runTests').disabled = true;
            document.getElementById('testResults').innerHTML = '';
            passed = 0; failed = 0; total = 0;
            updateSummary();

            for (const test of tests) {
                try {
                    const detail = test.run();
                    displayTest(test.name, 'pass', 'Passed', typeof detail === 'string' ? detail : null);
                } catch (err) {
                    displayTest(test.name, 'fail', err.message);
                }
            }

            document.getElementById('runTests').disabled = false;
        }

        window.onload = runAllTests;
    </script>
</body>
</html>
